<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hybrid ML-KEM-1024 + P-256 (HKDF + AES-256-GCM)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline'; img-src 'self' data:; base-uri 'none'; form-action 'none'; connect-src 'none';">
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  textarea, button { width: 100%; margin: 10px 0; padding: 10px; font-size: 16px; }
  textarea { height: 120px; }
  .output { background-color: #f8f9fa; border: 1px solid #ddd; padding: 10px; margin-top: 10px; height: 150px; overflow-y: auto; overflow-x: hidden; white-space: pre-wrap; word-break: break-all; font-family: ui-monospace, monospace; }
</style>
</head>
<body>
  <h1>Hybrid ML-KEM-1024 + P-256 (HKDF + AES-256-GCM)</h1>

  <button id="generateBtn" onclick="generateKeys()">Generate Hybrid Key Pair</button>
  <button onclick="clearAll()">Clear All</button>

  <h3>Public Key (Base64)</h3>
  <textarea id="publicKey" placeholder="Public key will appear here..."></textarea>
  <button onclick="copyText('publicKey')">Copy Public Key</button>
  <button onclick="clearField('publicKey')">Clear</button>

  <h3>Private Key (Base64)</h3>
  <textarea id="privateKey" placeholder="Private key will appear here..."></textarea>
  <button onclick="copyText('privateKey')">Copy Private Key</button>
  <button onclick="clearField('privateKey')">Clear</button>

  <h3>Text to Encrypt</h3>
  <textarea id="plaintext" placeholder="Enter text to encrypt..."></textarea>
  <button onclick="encryptText()">Encrypt</button>
  <button onclick="clearField('plaintext')">Clear</button>

  <h3>Text to Decrypt</h3>
  <textarea id="ciphertext" placeholder="Paste encrypted text here..."></textarea>
  <button onclick="decryptText()">Decrypt</button>
  <button onclick="clearField('ciphertext')">Clear</button>

  <h3 id="outputLabel">Output</h3>
  <textarea id="outputMessage" class="output" readonly placeholder="Output will appear here..."></textarea>
  <button onclick="copyText('outputMessage')">Copy Output</button>
  <script>
    var noblePostQuantum=(()=>{var Mt=Object.defineProperty;var xn=Object.getOwnPropertyDescriptor;var gn=Object.getOwnPropertyNames;var mn=Object.prototype.hasOwnProperty;var An=(e,t)=>{for(var r in t)Mt(e,r,{get:t[r],enumerable:!0})},wn=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of gn(t))!mn.call(e,o)&&o!==r&&Mt(e,o,{get:()=>t[o],enumerable:!(n=xn(t,o))||n.enumerable});return e};var Un=e=>wn(Mt({},"__esModule",{value:!0}),e);var no={};An(no,{ml_dsa44:()=>Wr,ml_dsa65:()=>Vr,ml_dsa87:()=>Xr,ml_kem1024:()=>Zr,ml_kem512:()=>Yr,ml_kem768:()=>zr,slh_dsa_sha2_128f:()=>ln,slh_dsa_sha2_128s:()=>dn,slh_dsa_sha2_192f:()=>hn,slh_dsa_sha2_192s:()=>yn,slh_dsa_sha2_256f:()=>pn,slh_dsa_sha2_256s:()=>bn,slh_dsa_shake_128f:()=>rn,slh_dsa_shake_128s:()=>nn,slh_dsa_shake_192f:()=>on,slh_dsa_shake_192s:()=>sn,slh_dsa_shake_256f:()=>cn,slh_dsa_shake_256s:()=>an});function Dt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function it(e,t=""){if(!Number.isSafeInteger(e)||e<0){let r=t&&`"${t}" `;throw new Error(`${r}expected integer >0, got ${e}`)}}function M(e,t,r=""){let n=Dt(e),o=e?.length,s=t!==void 0;if(!n||s&&o!==t){let c=r&&`"${r}" `,i=s?` of length ${t}`:"",u=n?`length=${o}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function ar(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");it(e.outputLen),it(e.blockLen)}function Le(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Tt(e,t){M(e,void 0,"digestInto() output");let r=t.outputLen;if(e.length<r)throw new Error('"digestInto() output" expected to be of length >='+r)}function St(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ge(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function We(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function we(e,t){return e<<32-t|e>>>t}var Tn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Sn(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function _n(e){for(let t=0;t<e.length;t++)e[t]=Sn(e[t]);return e}var vt=Tn?e=>e:_n,ur=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",En=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function fr(e){if(M(e),ur)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=En[e[r]];return t}var Ee={_0:48,_9:57,A:65,F:70,a:97,f:102};function ir(e){if(e>=Ee._0&&e<=Ee._9)return e-Ee._0;if(e>=Ee.A&&e<=Ee.F)return e-(Ee.A-10);if(e>=Ee.a&&e<=Ee.f)return e-(Ee.a-10)}function lr(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(ur)return Uint8Array.fromHex(e);let t=e.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){let c=ir(e.charCodeAt(s)),i=ir(e.charCodeAt(s+1));if(c===void 0||i===void 0){let u=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+u+'" at index '+s)}n[o]=c*16+i}return n}function Ve(...e){let t=0;for(let n=0;n<e.length;n++){let o=e[n];M(o),t+=o.length}let r=new Uint8Array(t);for(let n=0,o=0;n<e.length;n++){let s=e[n];r.set(s,o),o+=s.length}return r}function Je(e,t={}){let r=(o,s)=>e(s).update(o).digest(),n=e(void 0);return r.outputLen=n.outputLen,r.blockLen=n.blockLen,r.create=o=>e(o),Object.assign(r,t),Object.freeze(r)}function dr(e=32){let t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}var Re=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function hr(e,t=""){if(typeof e!="boolean"){let r=t&&`"${t}" `;throw new Error(r+"expected boolean, got type="+typeof e)}return e}var _t=BigInt(4294967295),yr=BigInt(32);function Ln(e,t=!1){return t?{h:Number(e&_t),l:Number(e>>yr&_t)}:{h:Number(e>>yr&_t)|0,l:Number(e&_t)|0}}function Et(e,t=!1){let r=e.length,n=new Uint32Array(r),o=new Uint32Array(r);for(let s=0;s<r;s++){let{h:c,l:i}=Ln(e[s],t);[n[s],o[s]]=[c,i]}return[n,o]}var Nt=(e,t,r)=>e>>>r,Gt=(e,t,r)=>e<<32-r|t>>>r,Xe=(e,t,r)=>e>>>r|t<<32-r,$e=(e,t,r)=>e<<32-r|t>>>r,at=(e,t,r)=>e<<64-r|t>>>r-32,ut=(e,t,r)=>e>>>r-32|t<<64-r;var pr=(e,t,r)=>e<<r|t>>>32-r,br=(e,t,r)=>t<<r|e>>>32-r,xr=(e,t,r)=>t<<r-32|e>>>64-r,gr=(e,t,r)=>e<<r-32|t>>>64-r;function Te(e,t,r,n){let o=(t>>>0)+(n>>>0);return{h:e+r+(o/2**32|0)|0,l:o|0}}var mr=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),Ar=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,wr=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),Ur=(e,t,r,n,o)=>t+r+n+o+(e/2**32|0)|0,Tr=(e,t,r,n,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(o>>>0),Sr=(e,t,r,n,o,s)=>t+r+n+o+s+(e/2**32|0)|0;var Bn=BigInt(0),ft=BigInt(1),Hn=BigInt(2),On=BigInt(7),Cn=BigInt(256),In=BigInt(113),Lr=[],kr=[],Br=[];for(let e=0,t=ft,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],Lr.push(2*(5*n+r)),kr.push((e+1)*(e+2)/2%64);let o=Bn;for(let s=0;s<7;s++)t=(t<<ft^(t>>On)*In)%Cn,t&Hn&&(o^=ft<<(ft<<BigInt(s))-ft);Br.push(o)}var Hr=Et(Br,!0),Pn=Hr[0],Rn=Hr[1],_r=(e,t,r)=>r>32?xr(e,t,r):pr(e,t,r),Er=(e,t,r)=>r>32?gr(e,t,r):br(e,t,r);function Fn(e,t=24){let r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let c=0;c<10;c++)r[c]=e[c]^e[c+10]^e[c+20]^e[c+30]^e[c+40];for(let c=0;c<10;c+=2){let i=(c+8)%10,u=(c+2)%10,U=r[u],a=r[u+1],l=_r(U,a,1)^r[i],S=Er(U,a,1)^r[i+1];for(let m=0;m<50;m+=10)e[c+m]^=l,e[c+m+1]^=S}let o=e[2],s=e[3];for(let c=0;c<24;c++){let i=kr[c],u=_r(o,s,i),U=Er(o,s,i),a=Lr[c];o=e[a],s=e[a+1],e[a]=u,e[a+1]=U}for(let c=0;c<50;c+=10){for(let i=0;i<10;i++)r[i]=e[c+i];for(let i=0;i<10;i++)e[c+i]^=~r[(i+2)%10]&r[(i+4)%10]}e[0]^=Pn[n],e[1]^=Rn[n]}ge(r)}var Lt=class e{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,r,n,o=!1,s=24){if(this.blockLen=t,this.suffix=r,this.outputLen=n,this.enableXOF=o,this.rounds=s,it(n,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=St(this.state)}clone(){return this._cloneInto()}keccak(){vt(this.state32),Fn(this.state32,this.rounds),vt(this.state32),this.posOut=0,this.pos=0}update(t){Le(this),M(t);let{blockLen:r,state:n}=this,o=t.length;for(let s=0;s<o;){let c=Math.min(r-this.pos,o-s);for(let i=0;i<c;i++)n[this.pos++]^=t[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:t,suffix:r,pos:n,blockLen:o}=this;t[n]^=r,(r&128)!==0&&n===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){Le(this,!1),M(t),this.finish();let r=this.state,{blockLen:n}=this;for(let o=0,s=t.length;o<s;){this.posOut>=n&&this.keccak();let c=Math.min(n-this.posOut,s-o);t.set(r.subarray(this.posOut,this.posOut+c),o),this.posOut+=c,o+=c}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return it(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Tt(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ge(this.state)}_cloneInto(t){let{blockLen:r,suffix:n,outputLen:o,rounds:s,enableXOF:c}=this;return t||=new e(r,n,o,c,s),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=n,t.outputLen=o,t.enableXOF=c,t.destroyed=this.destroyed,t}},Or=(e,t,r,n={})=>Je(()=>new Lt(t,e,r),n);var Cr=Or(6,136,32,Re(8));var Ir=Or(6,72,64,Re(10));var Pr=(e,t,r,n={})=>Je((o={})=>new Lt(t,e,o.dkLen===void 0?r:o.dkLen,!0),n),Rr=Pr(31,168,16,Re(11)),ee=Pr(31,136,32,Re(12));function jt(e){if(!Number.isSafeInteger(e)||e<0||e>4294967295)throw new Error("wrong u32 integer:"+e);return e}function Kr(e){return jt(e),(e&e-1)===0&&e!==0}function Wt(e,t){jt(e);let r=0;for(let n=0;n<t;n++,e>>>=1)r=r<<1|e&1;return r}function Mr(e){return jt(e),31-Math.clz32(e)}function Fr(e){let t=e.length;if(t<2||!Kr(t))throw new Error("n must be a power of 2 and greater than 1. Got "+t);let r=Mr(t);for(let n=0;n<t;n++){let o=Wt(n,r);if(n<o){let s=e[n];e[n]=e[o],e[o]=s}}return e}var Vt=(e,t)=>{let{N:r,roots:n,dit:o,invertButterflies:s=!1,skipStages:c=0,brp:i=!0}=t,u=Mr(r);if(!Kr(r))throw new Error("FFT: Polynomial size should be power of two");let U=o!==s;return a=>{if(a.length!==r)throw new Error("FFT: wrong Polynomial length");o&&i&&Fr(a);for(let l=0,S=1;l<u-c;l++){let m=o?l+1+c:u-l,B=1<<m,P=B>>1,F=r>>m;for(let K=0;K<r;K+=B)for(let A=0,h=S++;A<P;A++){let H=s?o?r-h:h:A*F,R=K+A,D=K+A+P,X=n[H],x=a[D],C=a[R];if(U){let W=e.mul(x,X);a[R]=e.add(C,W),a[D]=e.sub(C,W)}else s?(a[R]=e.add(x,C),a[D]=e.mul(e.sub(x,C),X)):(a[R]=e.add(C,x),a[D]=e.mul(e.sub(C,x),X))}}return!o&&i&&Fr(a),a}};var ke=dr;function Be(e,t){if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return r===0}function et(e){return Uint8Array.from(e)}function Xt(e){if(typeof e!="object"||e===null||Dt(e))throw new Error("expected opts to be an object")}function Ye(e){Xt(e),e.context!==void 0&&M(e.context,void 0,"opts.context")}function Fe(e){Ye(e),e.extraEntropy!==!1&&e.extraEntropy!==void 0&&M(e.extraEntropy,void 0,"opts.extraEntropy")}function ne(e,...t){let r=o=>typeof o=="number"?o:o.bytesLen,n=t.reduce((o,s)=>o+r(s),0);return{bytesLen:n,encode:o=>{let s=new Uint8Array(n);for(let c=0,i=0;c<t.length;c++){let u=t[c],U=r(u),a=typeof u=="number"?o[c]:u.encode(o[c]);M(a,U,e),s.set(a,i),typeof u!="number"&&a.fill(0),i+=U}return s},decode:o=>{M(o,n,e);let s=[];for(let c of t){let i=r(c),u=o.subarray(0,i);s.push(typeof c=="number"?u:c.decode(u)),o=o.subarray(i)}return s}}}function be(e,t){let r=t*e.bytesLen;return{bytesLen:r,encode:n=>{if(n.length!==t)throw new Error(`vecCoder.encode: wrong length=${n.length}. Expected: ${t}`);let o=new Uint8Array(r);for(let s=0,c=0;s<n.length;s++){let i=e.encode(n[s]);o.set(i,c),i.fill(0),c+=i.length}return o},decode:n=>{M(n,r);let o=[];for(let s=0;s<n.length;s+=e.bytesLen)o.push(e.decode(n.subarray(s,s+e.bytesLen)));return o}}}function Y(...e){for(let t of e)if(Array.isArray(t))for(let r of t)r.fill(0);else t.fill(0)}function tt(e){return(1<<e)-1}var Dr=Uint8Array.of();function rt(e,t=Dr){if(M(e),M(t),t.length>255)throw new Error("context should be less than 255 bytes");return Ve(new Uint8Array([0,t.length]),t,e)}var Kn=Uint8Array.from([6,9,96,134,72,1,101,3,4,2]);function kt(e,t=0){if(!e.oid||!Be(e.oid.subarray(0,10),Kn))throw new Error("hash.oid is invalid: expected NIST hash");let r=e.outputLen*8/2;if(t>r)throw new Error("Pre-hash security strength too low: "+r+", required: "+t)}function nt(e,t,r=Dr){if(M(t),M(r),r.length>255)throw new Error("context should be less than 255 bytes");let n=e(t);return Ve(new Uint8Array([1,r.length]),r,e.oid,n)}var Bt=e=>{let{newPoly:t,N:r,Q:n,F:o,ROOT_OF_UNITY:s,brvBits:c,isKyber:i}=e,u=(A,h=n)=>{let H=A%h|0;return(H>=0?H|0:h+H|0)|0},U=(A,h=n)=>{let H=u(A,h)|0;return(H>h>>1?H-h|0:H)|0};function a(){let A=t(r);for(let h=0;h<r;h++){let H=Wt(h,c),R=BigInt(s)**BigInt(H)%BigInt(n);A[h]=Number(R)|0}return A}let l=a(),S={add:(A,h)=>u((A|0)+(h|0))|0,sub:(A,h)=>u((A|0)-(h|0))|0,mul:(A,h)=>u((A|0)*(h|0))|0,inv:A=>{throw new Error("not implemented")}},m={N:r,roots:l,invertButterflies:!0,skipStages:i?1:0,brp:!1},B=Vt(S,{dit:!1,...m}),P=Vt(S,{dit:!0,...m});return{mod:u,smod:U,nttZetas:l,NTT:{encode:A=>B(A),decode:A=>{P(A);for(let h=0;h<A.length;h++)A[h]=u(o*A[h]);return A}},bitsCoder:(A,h)=>{let H=tt(A),R=A*(r/8);return{bytesLen:R,encode:D=>{let X=new Uint8Array(R);for(let x=0,C=0,W=0,V=0;x<D.length;x++)for(C|=(h.encode(D[x])&H)<<W,W+=A;W>=8;W-=8,C>>=8)X[V++]=C&tt(W);return X},decode:D=>{let X=t(r);for(let x=0,C=0,W=0,V=0;x<D.length;x++)for(C|=D[x]<<W,W+=8;W>=A;W-=A,C>>=A)X[V++]=h.decode(C&H);return X}}}}},vr=e=>(t,r)=>{r||(r=e.blockLen);let n=new Uint8Array(t.length+2);n.set(t);let o=t.length,s=new Uint8Array(r),c=e.create({}),i=0,u=0;return{stats:()=>({calls:i,xofs:u}),get:(U,a)=>(n[o+0]=U,n[o+1]=a,c.destroy(),c=e.create({}).update(n),i++,()=>(u++,c.xofInto(s))),clean:()=>{c.destroy(),Y(s,n)}}},ot=vr(Rr),Ht=vr(ee);function Nr(e){Xt(e),e.externalMu!==void 0&&hr(e.externalMu,"opts.externalMu")}var Z=256,De=8380417,Mn=1753,Dn=8347681,Ze=13,$t=Math.floor((De-1)/88)|0,Yt=Math.floor((De-1)/32)|0,zt={2:{K:4,L:4,D:Ze,GAMMA1:2**17,GAMMA2:$t,TAU:39,ETA:2,OMEGA:80},3:{K:6,L:5,D:Ze,GAMMA1:2**19,GAMMA2:Yt,TAU:49,ETA:4,OMEGA:55},5:{K:8,L:7,D:Ze,GAMMA1:2**19,GAMMA2:Yt,TAU:60,ETA:2,OMEGA:75}},xe=e=>new Int32Array(e),{mod:ze,smod:Ct,NTT:ie,bitsCoder:vn}=Bt({N:Z,Q:De,F:Dn,ROOT_OF_UNITY:Mn,newPoly:xe,isKyber:!1,brvBits:8}),Gr=e=>e,lt=(e,t=Gr,r=Gr)=>vn(e,{encode:n=>t(r(n)),decode:n=>r(t(n))}),Ke=(e,t)=>{for(let r=0;r<e.length;r++)e[r]=ze(e[r]+t[r]);return e},jr=(e,t)=>{for(let r=0;r<e.length;r++)e[r]=ze(e[r]-t[r]);return e},Nn=e=>{for(let t=0;t<Z;t++)e[t]<<=Ze;return e},dt=(e,t)=>{for(let r=0;r<Z;r++)if(Math.abs(Ct(e[r]))>=t)return!0;return!1},Me=(e,t)=>{let r=xe(Z);for(let n=0;n<e.length;n++)r[n]=ze(e[n]*t[n]);return r};function Ot(e){let t=xe(Z);for(let r=0;r<Z;){let n=e();if(n.length%3)throw new Error("RejNTTPoly: unaligned block");for(let o=0;r<Z&&o<=n.length-3;o+=3){let s=(n[o+0]|n[o+1]<<8|n[o+2]<<16)&8388607;s<De&&(t[r++]=s)}}return t}function Zt(e){let{K:t,L:r,GAMMA1:n,GAMMA2:o,TAU:s,ETA:c,OMEGA:i}=e,{CRH_BYTES:u,TR_BYTES:U,C_TILDE_BYTES:a,XOF128:l,XOF256:S,securityLevel:m}=e;if(![2,4].includes(c))throw new Error("Wrong ETA");if(![1<<17,1<<19].includes(n))throw new Error("Wrong GAMMA1");if(![$t,Yt].includes(o))throw new Error("Wrong GAMMA2");let B=s*c,P=y=>{let _=ze(y),g=Ct(_,2*o)|0;return _-g===De-1?{r1:0,r0:g-1|0}:{r1:Math.floor((_-g)/(2*o))|0,r0:g}},F=y=>P(y).r1,K=y=>P(y).r0,A=(y,_)=>y<=o||y>De-o||y===De-o&&_===0?0:1,h=(y,_)=>{let g=Math.floor((De-1)/(2*o)),{r1:b,r0:d}=P(_);return y===1?d>0?ze(b+1,g)|0:ze(b-1,g)|0:b|0},H=y=>{let _=ze(y),g=Ct(_,2**Ze)|0;return{r1:Math.floor((_-g)/2**Ze)|0,r0:g}},R={bytesLen:i+t,encode:y=>{if(y===!1)throw new Error("hint.encode: hint is false");let _=new Uint8Array(i+t);for(let g=0,b=0;g<t;g++){for(let d=0;d<Z;d++)y[g][d]!==0&&(_[b++]=d);_[i+g]=b}return _},decode:y=>{let _=[],g=0;for(let b=0;b<t;b++){let d=xe(Z);if(y[i+b]<g||y[i+b]>i)return!1;for(let f=g;f<y[i+b];f++){if(f>g&&y[f]<=y[f-1])return!1;d[y[f]]=1}g=y[i+b],_.push(d)}for(let b=g;b<i;b++)if(y[b]!==0)return!1;return _}},D=lt(c===2?3:4,y=>c-y,y=>{if(!(-c<=y&&y<=c))throw new Error(`malformed key s1/s3 ${y} outside of ETA range [${-c}, ${c}]`);return y}),X=lt(13,y=>(1<<Ze-1)-y),x=lt(10),C=lt(n===1<<17?18:20,y=>Ct(n-y)),W=lt(o===$t?6:4),V=be(W,t),oe=ne("publicKey",32,be(x,t)),he=ne("secretKey",32,32,U,be(D,r),be(D,t),be(X,t)),ye=ne("signature",a,be(C,r),R),Ue=c===2?y=>y<15?2-y%5:!1:y=>y<9?4-y:!1;function ct(y){let _=xe(Z);for(let g=0;g<Z;){let b=y();for(let d=0;g<Z&&d<b.length;d+=1){let f=Ue(b[d]&15),T=Ue(b[d]>>4&15);f!==!1&&(_[g++]=f),g<Z&&T!==!1&&(_[g++]=T)}}return _}let xt=y=>{let _=xe(Z),g=ee.create({}).update(y),b=new Uint8Array(ee.blockLen);g.xofInto(b);let d=b.slice(0,8);for(let f=Z-s,T=8,p=0,E=0;f<Z;f++){let O=f+1;for(;O>f;)O=b[T++],!(T<ee.blockLen)&&(g.xofInto(b),T=0);_[f]=_[O],_[O]=1-((d[p]>>E++&1)<<1),E>=8&&(p++,E=0)}return _},gt=y=>{let _=xe(Z),g=xe(Z);for(let b=0;b<y.length;b++){let{r0:d,r1:f}=H(y[b]);_[b]=d,g[b]=f}return{r0:_,r1:g}},mt=(y,_)=>{for(let g=0;g<Z;g++)y[g]=h(_[g],y[g]);return y},At=(y,_)=>{let g=xe(Z),b=0;for(let d=0;d<Z;d++){let f=A(y[d],_[d]);g[d]=f,b+=f}return{v:g,cnt:b}},je=32,Ce=ne("seed",32,64,32),ue={info:{type:"internal-ml-dsa"},lengths:{secretKey:he.bytesLen,publicKey:oe.bytesLen,seed:32,signature:ye.bytesLen,signRand:je},keygen:y=>{let _=new Uint8Array(34),g=y===void 0;g&&(y=ke(32)),M(y,32,"seed"),_.set(y),g&&Y(y),_[32]=t,_[33]=r;let[b,d,f]=Ce.decode(ee(_,{dkLen:Ce.bytesLen})),T=S(d),p=[];for(let w=0;w<r;w++)p.push(ct(T.get(w&255,w>>8&255)));let E=[];for(let w=r;w<r+t;w++)E.push(ct(T.get(w&255,w>>8&255)));let O=p.map(w=>ie.encode(w.slice())),k=[],I=[],N=l(b),L=xe(Z);for(let w=0;w<t;w++){Y(L);for(let z=0;z<r;z++){let Q=Ot(N.get(z,w));Ke(L,Me(Q,O[z]))}ie.decode(L);let{r0:$,r1:q}=gt(Ke(L,E[w]));k.push($),I.push(q)}let G=oe.encode([b,I]),v=ee(G,{dkLen:U}),te=he.encode([b,f,v,p,E,k]);return N.clean(),T.clean(),Y(b,d,f,p,E,O,L,k,I,v,_),{publicKey:G,secretKey:te}},getPublicKey:y=>{let[_,g,b,d,f,T]=he.decode(y),p=l(_),E=d.map(I=>ie.encode(I.slice())),O=[],k=xe(Z);for(let I=0;I<t;I++){k.fill(0);for(let L=0;L<r;L++){let G=Ot(p.get(L,I));Ke(k,Me(G,E[L]))}ie.decode(k),Ke(k,f[I]);let{r1:N}=gt(k);O.push(N)}return p.clean(),Y(k,E,T,d,f),oe.encode([_,O])},sign:(y,_,g={})=>{Fe(g),Nr(g);let{extraEntropy:b,externalMu:d=!1}=g,[f,T,p,E,O,k]=he.decode(_),I=[],N=l(f);for(let w=0;w<t;w++){let $=[];for(let q=0;q<r;q++)$.push(Ot(N.get(q,w)));I.push($)}N.clean();for(let w=0;w<r;w++)ie.encode(E[w]);for(let w=0;w<t;w++)ie.encode(O[w]),ie.encode(k[w]);let L=d?y:ee.create({dkLen:u}).update(p).update(y).digest(),G=b===!1?new Uint8Array(32):b===void 0?ke(je):b;M(G,32,"extraEntropy");let v=ee.create({dkLen:u}).update(T).update(G).update(L).digest();M(v,u);let te=S(v,C.bytesLen);e:for(let w=0;;){let $=[];for(let j=0;j<r;j++,w++)$.push(C.decode(te.get(w&255,w>>8)()));let q=$.map(j=>ie.encode(j.slice())),z=[];for(let j=0;j<t;j++){let J=xe(Z);for(let ce=0;ce<r;ce++)Ke(J,Me(I[j][ce],q[ce]));ie.decode(J),z.push(J)}let Q=z.map(j=>j.map(F)),se=ee.create({dkLen:a}).update(L).update(V.encode(Q)).digest(),pe=ie.encode(xt(se)),Se=E.map(j=>Me(j,pe));for(let j=0;j<r;j++)if(Ke(ie.decode(Se[j]),$[j]),dt(Se[j],n-B))continue e;let Ie=0,re=[];for(let j=0;j<t;j++){let J=ie.decode(Me(O[j],pe)),ce=jr(z[j],J).map(K);if(dt(ce,o-B))continue e;let de=ie.decode(Me(k[j],pe));if(dt(de,o))continue e;Ke(ce,de);let _e=At(ce,Q[j]);re.push(_e.v),Ie+=_e.cnt}if(Ie>i)continue;te.clean();let Pe=ye.encode([se,Se,re]);return Y(se,Se,re,pe,Q,z,q,$,v,L,E,O,k,...I),Pe}throw new Error("Unreachable code path reached, report this error")},verify:(y,_,g,b={})=>{Nr(b);let{externalMu:d=!1}=b,[f,T]=oe.decode(g),p=ee(g,{dkLen:U});if(y.length!==ye.bytesLen)return!1;let[E,O,k]=ye.decode(y);if(k===!1)return!1;for(let w=0;w<r;w++)if(dt(O[w],n-B))return!1;let I=d?_:ee.create({dkLen:u}).update(p).update(_).digest(),N=ie.encode(xt(E)),L=O.map(w=>w.slice());for(let w=0;w<r;w++)ie.encode(L[w]);let G=[],v=l(f);for(let w=0;w<t;w++){let $=Me(ie.encode(Nn(T[w])),N),q=xe(Z);for(let Q=0;Q<r;Q++){let se=Ot(v.get(Q,w));Ke(q,Me(se,L[Q]))}let z=ie.decode(jr(q,$));G.push(mt(z,k[w]))}v.clean();let te=ee.create({dkLen:a}).update(I).update(V.encode(G)).digest();for(let w of k)if(!(w.reduce((q,z)=>q+z,0)<=i))return!1;for(let w of O)if(dt(w,n-B))return!1;return Be(E,te)}};return{info:{type:"ml-dsa"},internal:ue,securityLevel:m,keygen:ue.keygen,lengths:ue.lengths,getPublicKey:ue.getPublicKey,sign:(y,_,g={})=>{Fe(g);let b=rt(y,g.context),d=ue.sign(b,_,g);return Y(b),d},verify:(y,_,g,b={})=>(Ye(b),ue.verify(y,rt(_,b.context),g)),prehash:y=>(kt(y,m),{info:{type:"hashml-dsa"},securityLevel:m,lengths:ue.lengths,keygen:ue.keygen,getPublicKey:ue.getPublicKey,sign:(_,g,b={})=>{Fe(b);let d=nt(y,_,b.context),f=ue.sign(d,g,b);return Y(d),f},verify:(_,g,b,d={})=>(Ye(d),ue.verify(_,nt(y,g,d.context),b))})}}var Wr=Zt({...zt[2],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:32,XOF128:ot,XOF256:Ht,securityLevel:128}),Vr=Zt({...zt[3],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:48,XOF128:ot,XOF256:Ht,securityLevel:192}),Xr=Zt({...zt[5],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:64,XOF128:ot,XOF256:Ht,securityLevel:256});var fe=256,He=3329,Gn=3303,jn=17,{mod:pt,nttZetas:Wn,NTT:qe,bitsCoder:Vn}=Bt({N:fe,Q:He,F:Gn,ROOT_OF_UNITY:jn,newPoly:e=>new Uint16Array(e),brvBits:7,isKyber:!0}),qt={512:{N:fe,Q:He,K:2,ETA1:3,ETA2:2,du:10,dv:4,RBGstrength:128},768:{N:fe,Q:He,K:3,ETA1:2,ETA2:2,du:10,dv:4,RBGstrength:192},1024:{N:fe,Q:He,K:4,ETA1:2,ETA2:2,du:11,dv:5,RBGstrength:256}},Xn=e=>{if(e>=12)return{encode:r=>r,decode:r=>r};let t=2**(e-1);return{encode:r=>((r<<e)+He/2)/He,decode:r=>r*He+t>>>e}},ht=e=>Vn(e,Xn(e));function Qe(e,t){for(let r=0;r<fe;r++)e[r]=pt(e[r]+t[r])}function $n(e,t){for(let r=0;r<fe;r++)e[r]=pt(e[r]-t[r])}function Yn(e,t,r,n,o){let s=pt(t*n*o+e*r),c=pt(e*n+t*r);return{c0:s,c1:c}}function It(e,t){for(let r=0;r<fe/2;r++){let n=Wn[64+(r>>1)];r&1&&(n=-n);let{c0:o,c1:s}=Yn(e[2*r+0],e[2*r+1],t[2*r+0],t[2*r+1],n);e[2*r+0]=o,e[2*r+1]=s}return e}function $r(e){let t=new Uint16Array(fe);for(let r=0;r<fe;){let n=e();if(n.length%3)throw new Error("SampleNTT: unaligned block");for(let o=0;r<fe&&o+3<=n.length;o+=3){let s=(n[o+0]>>0|n[o+1]<<8)&4095,c=(n[o+1]>>4|n[o+2]<<4)&4095;s<He&&(t[r++]=s),r<fe&&c<He&&(t[r++]=c)}}return t}function yt(e,t,r,n){let o=e(n*fe/4,t,r),s=new Uint16Array(fe),c=St(o),i=0;for(let u=0,U=0,a=0,l=0;u<c.length;u++){let S=c[u];for(let m=0;m<32;m++)a+=S&1,S>>=1,i+=1,i===n?(l=a,a=0):i===2*n&&(s[U++]=pt(l-a),a=0,i=0)}if(i)throw new Error(`sampleCBD: leftover bits: ${i}`);return s}var zn=e=>{let{K:t,PRF:r,XOF:n,HASH512:o,ETA1:s,ETA2:c,du:i,dv:u}=e,U=ht(1),a=ht(u),l=ht(i),S=ne("publicKey",be(ht(12),t),32),m=be(ht(12),t),B=ne("ciphertext",be(l,t),a),P=ne("seed",32,32);return{secretCoder:m,lengths:{secretKey:m.bytesLen,publicKey:S.bytesLen,cipherText:B.bytesLen},keygen:F=>{M(F,32,"seed");let K=new Uint8Array(33);K.set(F),K[32]=t;let A=o(K),[h,H]=P.decode(A),R=[],D=[];for(let C=0;C<t;C++)R.push(qe.encode(yt(r,H,C,s)));let X=n(h);for(let C=0;C<t;C++){let W=qe.encode(yt(r,H,t+C,s));for(let V=0;V<t;V++){let oe=$r(X.get(V,C));Qe(W,It(oe,R[V]))}D.push(W)}X.clean();let x={publicKey:S.encode([D,h]),secretKey:m.encode(R)};return Y(h,H,R,D,K,A),x},encrypt:(F,K,A)=>{let[h,H]=S.decode(F),R=[];for(let V=0;V<t;V++)R.push(qe.encode(yt(r,A,V,s)));let D=n(H),X=new Uint16Array(fe),x=[];for(let V=0;V<t;V++){let oe=yt(r,A,t+V,c),he=new Uint16Array(fe);for(let ye=0;ye<t;ye++){let Ue=$r(D.get(V,ye));Qe(he,It(Ue,R[ye]))}Qe(oe,qe.decode(he)),x.push(oe),Qe(X,It(h[V],R[V])),Y(he)}D.clean();let C=yt(r,A,2*t,c);Qe(C,qe.decode(X));let W=U.decode(K);return Qe(W,C),Y(h,R,X,C),B.encode([x,W])},decrypt:(F,K)=>{let[A,h]=B.decode(F),H=m.decode(K),R=new Uint16Array(fe);for(let D=0;D<t;D++)Qe(R,It(H[D],qe.encode(A[D])));return $n(h,qe.decode(R)),Y(R,H,A),U.encode(h)}}};function Qt(e){let t=zn(e),{HASH256:r,HASH512:n,KDF:o}=e,{secretCoder:s,lengths:c}=t,i=ne("secretKey",c.secretKey,c.publicKey,32,32),u=32,U=64;return{info:{type:"ml-kem"},lengths:{...c,seed:64,msg:u,msgRand:u,secretKey:i.bytesLen},keygen:(a=ke(U))=>{M(a,U,"seed");let{publicKey:l,secretKey:S}=t.keygen(a.subarray(0,32)),m=r(l),B=i.encode([S,l,m,a.subarray(32)]);return Y(S,m),{publicKey:l,secretKey:B}},getPublicKey:a=>{let[l,S,m,B]=i.decode(a);return Uint8Array.from(S)},encapsulate:(a,l=ke(u))=>{M(a,c.publicKey,"publicKey"),M(l,u,"message");let S=a.subarray(0,384*e.K),m=s.encode(s.decode(et(S)));if(!Be(m,S))throw Y(m),new Error("ML-KEM.encapsulate: wrong publicKey modulus");Y(m);let B=n.create().update(l).update(r(a)).digest(),P=t.encrypt(a,l,B.subarray(32,64));return Y(B.subarray(32)),{cipherText:P,sharedSecret:B.subarray(0,32)}},decapsulate:(a,l)=>{M(l,i.bytesLen,"secretKey"),M(a,c.cipherText,"cipherText");let S=i.bytesLen-96,m=S+32,B=r(l.subarray(S/2,m));if(!Be(B,l.subarray(m,m+32)))throw new Error("invalid secretKey: hash check failed");let[P,F,K,A]=i.decode(l),h=t.decrypt(a,P),H=n.create().update(h).update(K).digest(),R=H.subarray(0,32),D=t.encrypt(F,h,H.subarray(32,64)),X=Be(a,D),x=o.create({dkLen:32}).update(A).update(a).digest();return Y(h,D,X?x:R),X?R:x}}}function Zn(e,t,r){return ee.create({dkLen:e}).update(t).update(new Uint8Array([r])).digest()}var Jt={HASH256:Cr,HASH512:Ir,KDF:ee,XOF:ot,PRF:Zn},Yr=Qt({...Jt,...qt[512]}),zr=Qt({...Jt,...qt[768]}),Zr=Qt({...Jt,...qt[1024]});var Pt=class{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,r){if(ar(t),M(r,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?t.create().update(r).digest():r);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),ge(o)}update(t){return Le(this),this.iHash.update(t),this}digestInto(t){Le(this),M(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});let{oHash:r,iHash:n,finished:o,destroyed:s,blockLen:c,outputLen:i}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=c,t.outputLen=i,t.oHash=r._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},er=(e,t,r)=>new Pt(e,t).update(r).digest();er.create=(e,t)=>new Pt(e,t);function qr(e,t,r){return e&t^~e&r}function Qr(e,t,r){return e&t^e&r^t&r}var bt=class{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,r,n,o){this.blockLen=t,this.outputLen=r,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(t),this.view=We(this.buffer)}update(t){Le(this),M(t);let{view:r,buffer:n,blockLen:o}=this,s=t.length;for(let c=0;c<s;){let i=Math.min(o-this.pos,s-c);if(i===o){let u=We(t);for(;o<=s-c;c+=o)this.process(u,c);continue}n.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Le(this),Tt(t,this),this.finished=!0;let{buffer:r,view:n,blockLen:o,isLE:s}=this,{pos:c}=this;r[c++]=128,ge(this.buffer.subarray(c)),this.padOffset>o-c&&(this.process(n,0),c=0);for(let l=c;l<o;l++)r[l]=0;n.setBigUint64(o-8,BigInt(this.length*8),s),this.process(n,0);let i=We(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let U=u/4,a=this.get();if(U>a.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<U;l++)i.setUint32(4*l,a[l],s)}digest(){let{buffer:t,outputLen:r}=this;this.digestInto(t);let n=t.slice(0,r);return this.destroy(),n}_cloneInto(t){t||=new this.constructor,t.set(...this.get());let{blockLen:r,buffer:n,length:o,finished:s,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=s,t.length=o,t.pos=i,o%r&&t.buffer.set(n),t}clone(){return this._cloneInto()}},Oe=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var ae=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]);var qn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ve=new Uint32Array(64),tr=class extends bt{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:r,C:n,D:o,E:s,F:c,G:i,H:u}=this;return[t,r,n,o,s,c,i,u]}set(t,r,n,o,s,c,i,u){this.A=t|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,r){for(let l=0;l<16;l++,r+=4)ve[l]=t.getUint32(r,!1);for(let l=16;l<64;l++){let S=ve[l-15],m=ve[l-2],B=we(S,7)^we(S,18)^S>>>3,P=we(m,17)^we(m,19)^m>>>10;ve[l]=P+ve[l-7]+B+ve[l-16]|0}let{A:n,B:o,C:s,D:c,E:i,F:u,G:U,H:a}=this;for(let l=0;l<64;l++){let S=we(i,6)^we(i,11)^we(i,25),m=a+S+qr(i,u,U)+qn[l]+ve[l]|0,P=(we(n,2)^we(n,13)^we(n,22))+Qr(n,o,s)|0;a=U,U=u,u=i,i=c+m|0,c=s,s=o,o=n,n=m+P|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,U=U+this.G|0,a=a+this.H|0,this.set(n,o,s,c,i,u,U,a)}roundClean(){ge(ve)}destroy(){this.set(0,0,0,0,0,0,0,0),ge(this.buffer)}},rr=class extends tr{A=Oe[0]|0;B=Oe[1]|0;C=Oe[2]|0;D=Oe[3]|0;E=Oe[4]|0;F=Oe[5]|0;G=Oe[6]|0;H=Oe[7]|0;constructor(){super(32)}};var Jr=Et(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Qn=Jr[0],Jn=Jr[1],Ne=new Uint32Array(80),Ge=new Uint32Array(80),nr=class extends bt{constructor(t){super(128,t,16,!1)}get(){let{Ah:t,Al:r,Bh:n,Bl:o,Ch:s,Cl:c,Dh:i,Dl:u,Eh:U,El:a,Fh:l,Fl:S,Gh:m,Gl:B,Hh:P,Hl:F}=this;return[t,r,n,o,s,c,i,u,U,a,l,S,m,B,P,F]}set(t,r,n,o,s,c,i,u,U,a,l,S,m,B,P,F){this.Ah=t|0,this.Al=r|0,this.Bh=n|0,this.Bl=o|0,this.Ch=s|0,this.Cl=c|0,this.Dh=i|0,this.Dl=u|0,this.Eh=U|0,this.El=a|0,this.Fh=l|0,this.Fl=S|0,this.Gh=m|0,this.Gl=B|0,this.Hh=P|0,this.Hl=F|0}process(t,r){for(let h=0;h<16;h++,r+=4)Ne[h]=t.getUint32(r),Ge[h]=t.getUint32(r+=4);for(let h=16;h<80;h++){let H=Ne[h-15]|0,R=Ge[h-15]|0,D=Xe(H,R,1)^Xe(H,R,8)^Nt(H,R,7),X=$e(H,R,1)^$e(H,R,8)^Gt(H,R,7),x=Ne[h-2]|0,C=Ge[h-2]|0,W=Xe(x,C,19)^at(x,C,61)^Nt(x,C,6),V=$e(x,C,19)^ut(x,C,61)^Gt(x,C,6),oe=wr(X,V,Ge[h-7],Ge[h-16]),he=Ur(oe,D,W,Ne[h-7],Ne[h-16]);Ne[h]=he|0,Ge[h]=oe|0}let{Ah:n,Al:o,Bh:s,Bl:c,Ch:i,Cl:u,Dh:U,Dl:a,Eh:l,El:S,Fh:m,Fl:B,Gh:P,Gl:F,Hh:K,Hl:A}=this;for(let h=0;h<80;h++){let H=Xe(l,S,14)^Xe(l,S,18)^at(l,S,41),R=$e(l,S,14)^$e(l,S,18)^ut(l,S,41),D=l&m^~l&P,X=S&B^~S&F,x=Tr(A,R,X,Jn[h],Ge[h]),C=Sr(x,K,H,D,Qn[h],Ne[h]),W=x|0,V=Xe(n,o,28)^at(n,o,34)^at(n,o,39),oe=$e(n,o,28)^ut(n,o,34)^ut(n,o,39),he=n&s^n&i^s&i,ye=o&c^o&u^c&u;K=P|0,A=F|0,P=m|0,F=B|0,m=l|0,B=S|0,{h:l,l:S}=Te(U|0,a|0,C|0,W|0),U=i|0,a=u|0,i=s|0,u=c|0,s=n|0,c=o|0;let Ue=mr(W,oe,ye);n=Ar(Ue,C,V,he),o=Ue|0}({h:n,l:o}=Te(this.Ah|0,this.Al|0,n|0,o|0)),{h:s,l:c}=Te(this.Bh|0,this.Bl|0,s|0,c|0),{h:i,l:u}=Te(this.Ch|0,this.Cl|0,i|0,u|0),{h:U,l:a}=Te(this.Dh|0,this.Dl|0,U|0,a|0),{h:l,l:S}=Te(this.Eh|0,this.El|0,l|0,S|0),{h:m,l:B}=Te(this.Fh|0,this.Fl|0,m|0,B|0),{h:P,l:F}=Te(this.Gh|0,this.Gl|0,P|0,F|0),{h:K,l:A}=Te(this.Hh|0,this.Hl|0,K|0,A|0),this.set(n,o,s,c,i,u,U,a,l,S,m,B,P,F,K,A)}roundClean(){ge(Ne,Ge)}destroy(){ge(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},or=class extends nr{Ah=ae[0]|0;Al=ae[1]|0;Bh=ae[2]|0;Bl=ae[3]|0;Ch=ae[4]|0;Cl=ae[5]|0;Dh=ae[6]|0;Dl=ae[7]|0;Eh=ae[8]|0;El=ae[9]|0;Fh=ae[10]|0;Fl=ae[11]|0;Gh=ae[12]|0;Gl=ae[13]|0;Hh=ae[14]|0;Hl=ae[15]|0;constructor(){super(64)}};var Rt=Je(()=>new rr,Re(1));var en=Je(()=>new or,Re(3));var me={"128f":{W:16,N:16,H:66,D:22,K:33,A:6,securityLevel:128},"128s":{W:16,N:16,H:63,D:7,K:14,A:12,securityLevel:128},"192f":{W:16,N:24,H:66,D:22,K:33,A:8,securityLevel:192},"192s":{W:16,N:24,H:63,D:7,K:17,A:14,securityLevel:192},"256f":{W:16,N:32,H:68,D:17,K:35,A:9,securityLevel:256},"256s":{W:16,N:32,H:64,D:8,K:22,A:14,securityLevel:256}},le={WOTS:0,WOTSPK:1,HASHTREE:2,FORSTREE:3,FORSPK:4,WOTSPRF:5,FORSPRF:6};function eo(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":"0x"+e)}function tn(e){return eo(fr(e))}function to(e,t){return lr(e.toString(16).padStart(t*2,"0"))}var sr=(e,t)=>{let r=tt(t);return n=>{let o=new Uint32Array(e);for(let s=0,c=0,i=0,u=0;s<e;s++){for(;i<t;)u=u<<8|n[c++],i+=8;i-=t,o[s]=u>>>i&r}return o}};function cr(e){return(1n<<BigInt(e))-1n}function Ae(e,t){let{N:r,W:n,H:o,D:s,K:c,A:i,securityLevel:u}=e,U=t.getContext(e);if(n!==16)throw new Error("Unsupported Winternitz parameter");let a=4,l=Math.floor(8*r/a),S=r<=8?2:r<=136?3:4,m=Math.floor(o/s),B=l+S,P=22,F=0,K=1,A=9,h=12,H=13,R=17,D=18,X=21;t.isCompressed||(P=32,F+=3,K+=7,A+=10,h+=10,H+=10,R+=10,D+=10,X+=10);let x=(d,f=new Uint8Array(P))=>{let{type:T,height:p,tree:E,layer:O,index:k,chain:I,hash:N,keypair:L}=d,{subtreeAddr:G,keypairAddr:v}=d,te=We(f);return p!==void 0&&(f[R]=p),O!==void 0&&(f[F]=O),T!==void 0&&(f[A]=T),I!==void 0&&(f[R]=I),N!==void 0&&(f[X]=N),k!==void 0&&te.setUint32(D,k,!1),G&&f.set(G.subarray(0,K+8)),E!==void 0&&te.setBigUint64(K,E,!1),L!==void 0&&(f[H]=L,m>8&&(f[h]=L>>>8)),v&&(f.set(v.subarray(0,K+8)),f[H]=v[H],m>8&&(f[h]=v[h])),f},C=sr(S,a),W=d=>{let f=sr(l,a)(d),T=0;for(let O=0;O<f.length;O++)T+=n-1-f[O];T<<=(8-S*a%8)%8;let p=C(to(T,Math.ceil(S*a/8))),E=new Uint32Array(B);return E.set(f),E.set(p,f.length),E},V=sr(c,i),oe=m*(s-1),he=m,ye=ne("hashedMessage",Math.ceil(i*c/8),Math.ceil(oe/8),Math.ceil(m/8)),Ue=(d,f,T,p)=>{let E=p.Hmsg(d,f,T,ye.bytesLen),[O,k,I]=ye.decode(E),N=tn(k)&cr(oe),L=Number(tn(I))&tt(he);return{tree:N,leafIdx:L,md:O}},ct=(d,f)=>function(p,E,O,k,I){let N=(1<<d)-1,L=new Uint8Array(d*r),G=new Uint8Array(d*r);for(let v=0;;v++){let te=new Uint8Array(2*r),w=te.subarray(0,r),$=te.subarray(r),q=v+O;$.set(f(E,q,p,I));let z=0;for(let Q=v,se=O,pe=E;;z++,Q>>>=1,pe>>>=1,se>>>=1){if(z===d)return{root:$,authPath:G};if((Q^pe)===1&&G.subarray(z*r).set($),(Q&1)===0&&v<N)break;x({height:z+1,index:(Q>>1)+(se>>1)},k),w.set(L.subarray(z*r).subarray(0,r)),$.set(p.thashN(2,te,k))}L.subarray(z*r).set($)}throw new Error("Unreachable code path reached, report this error")},xt=ct(m,(d,f,T,p)=>{let E=new Uint8Array(B*r),O=f===d?0:-1>>>0;x({keypair:f},p.leafAddr),x({keypair:f},p.pkAddr);for(let k=0;k<B;k++){let I=p.wotsSteps[k]|O,N=E.subarray(k*r,(k+1)*r);x({chain:k,hash:0,type:le.WOTSPRF},p.leafAddr),N.set(T.PRFaddr(p.leafAddr)),x({type:le.WOTS},p.leafAddr);for(let L=0;L===I&&p.wotsSig.subarray(k*r).set(N),L!==n-1;L++)x({hash:L},p.leafAddr),N.set(T.thash1(N,p.leafAddr))}return T.thashN(B,E,p.pkAddr)}),gt=ct(i,(d,f,T,p)=>{x({type:le.FORSPRF,index:f},p);let E=T.PRFaddr(p);return x({type:le.FORSTREE},p),T.thash1(E,p)}),mt=(d,f,T,p,E=new Uint8Array(r))=>{x({type:le.HASHTREE},T);let O={wotsSig:new Uint8Array(_.bytesLen),wotsSteps:W(E),leafAddr:x({subtreeAddr:f}),pkAddr:x({type:le.WOTSPK,subtreeAddr:f})},{root:k,authPath:I}=xt(d,p,0,T,O);return{root:k,sigWots:O.wotsSig.subarray(0,B*r),sigAuth:I}},At=(d,f,T,p,E,O,k)=>{let I=new Uint8Array(2*r),N=I.subarray(0,r),L=I.subarray(r,2*r);(f&1)!==0?(L.set(d.subarray(0,r)),N.set(p.subarray(0,r))):(N.set(d.subarray(0,r)),L.set(p.subarray(0,r))),f>>>=1,T>>>=1;for(let G=0;G<E-1;G++,f>>=1,T>>=1){x({height:G+1,index:f+T},k);let v=p.subarray((G+1)*r,(G+2)*r);(f&1)!==0?(L.set(O.thashN(2,I,k)),N.set(v)):(I.set(O.thashN(2,I,k)),L.set(v))}return x({height:E,index:f+T},k),O.thashN(2,I,k)},je=ne("seed",r,r,r),Ce=ne("publicKey",r,r),ue=ne("secretKey",r,r,Ce.bytesLen),y=be(ne("fors",r,r*i),c),_=be(ne("wots",B*r,m*r),s),g=ne("signature",r,y,_),b={info:{type:"internal-slh-dsa"},lengths:{publicKey:Ce.bytesLen,secretKey:ue.bytesLen,signature:g.bytesLen,seed:je.bytesLen,signRand:r},keygen(d){d!==void 0&&M(d,je.bytesLen,"seed"),d=d===void 0?ke(je.bytesLen):et(d);let[f,T,p]=je.decode(d),E=U(p,f),O=x({layer:s-1}),k=x({layer:s-1}),{root:I}=mt(E,k,O,-1>>>0),N=Ce.encode([p,I]),L=ue.encode([f,T,N]);return E.clean(),Y(f,T,I,k,O),{publicKey:N,secretKey:L}},getPublicKey:d=>{let[f,T,p]=ue.decode(d);return Uint8Array.from(p)},sign:(d,f,T={})=>{Fe(T);let{extraEntropy:p}=T,[E,O,k]=ue.decode(f),[I,N]=Ce.decode(k);p===!1?p=et(I):p===void 0?p=ke(r):p=et(p),M(p,r);let L=U(I,E),G=L.PRFmsg(O,p,d),{tree:v,leafIdx:te,md:w}=Ue(G,k,d,L),$=x({type:le.WOTS,tree:v,keypair:te}),q=[],z=x({keypairAddr:$}),Q=x({keypairAddr:$}),se=V(w),pe=[];for(let J=0;J<se.length;J++){let ce=J<<i;x({type:le.FORSPRF,height:0,index:se[J]+ce},Q);let de=L.PRFaddr(Q);x({type:le.FORSTREE},Q);let{root:_e,authPath:wt}=gt(L,se[J],ce,Q,z);q.push(_e),pe.push([de,wt])}let Se=x({type:le.FORSPK,keypairAddr:$}),Ie=L.thashN(c,Ve(...q),Se),re=x({type:le.HASHTREE}),Pe=[];for(let J=0;J<s;J++,v>>=BigInt(m)){x({tree:v,layer:J},re),x({subtreeAddr:re,keypair:te},$);let{sigWots:ce,sigAuth:de,root:_e}=mt(L,$,re,te,Ie);Ie.set(_e),Y(_e),Pe.push([ce,de]),te=Number(v&cr(m))}L.clean();let j=g.encode([G,pe,Pe]);return Y(G,p,re,$,z,Q,se,q),j},verify:(d,f,T)=>{let[p,E]=Ce.decode(T),[O,k,I]=g.decode(d),N=T;if(d.length!==g.bytesLen)return!1;let L=U(p),{tree:G,leafIdx:v,md:te}=Ue(O,N,f,L),w=x({type:le.WOTS,tree:G,keypair:v}),$=[],q=x({type:le.FORSTREE,keypairAddr:w}),z=V(te);for(let re=0;re<k.length;re++){let[Pe,j]=k[re],J=re<<i;x({height:0,index:z[re]+J},q);let ce=L.thash1(Pe,q);$.push(At(ce,z[re],J,j,i,L,q))}let Q=x({type:le.FORSPK,keypairAddr:w}),se=L.thashN(c,Ve(...$),Q),pe=x({type:le.HASHTREE}),Se=x({type:le.WOTSPK}),Ie=new Uint8Array(B*r);for(let re=0;re<I.length;re++,G>>=BigInt(m)){let[Pe,j]=I[re];x({tree:G,layer:re},pe),x({subtreeAddr:pe,keypair:v},w),x({keypairAddr:w},Se);let J=W(se);for(let de=0;de<B;de++){x({chain:de},w);let _e=n-1-J[de],wt=J[de],Kt=Ie.subarray(de*r);Kt.set(Pe.subarray(de*r,(de+1)*r));for(let Ut=wt;Ut<wt+_e&&Ut<n;Ut++)x({hash:Ut},w),Kt.set(L.thash1(Kt,w))}let ce=L.thashN(B,Ie,Se);se=At(ce,v,0,j,m,L,pe),v=Number(G&cr(m))}return Be(se,E)}};return{info:{type:"slh-dsa"},internal:b,securityLevel:u,lengths:b.lengths,keygen:b.keygen,getPublicKey:b.getPublicKey,sign:(d,f,T={})=>{Fe(T);let p=rt(d,T.context),E=b.sign(p,f,T);return Y(p),E},verify:(d,f,T,p={})=>(Ye(p),b.verify(d,rt(f,p.context),T)),prehash:d=>(kt(d,u),{info:{type:"hashslh-dsa"},lengths:b.lengths,keygen:b.keygen,getPublicKey:b.getPublicKey,sign:(f,T,p={})=>{Fe(p);let E=nt(d,f,p.context),O=b.sign(E,T,p);return Y(E),O},verify:(f,T,p,E={})=>(Ye(E),b.verify(f,nt(d,T,E.context),p))})}}var ro=()=>e=>(t,r)=>{let{N:n}=e,o={prf:0,thash:0,hmsg:0,gen_message_random:0},s=ee.create({}).update(t),c=s.clone(),i=(u,U,a)=>(o.thash++,s._cloneInto(c).update(a).update(U.subarray(0,u*n)).xof(n));return{PRFaddr:u=>{if(!r)throw new Error("no sk seed");return o.prf++,s._cloneInto(c).update(u).update(r).xof(n)},PRFmsg:(u,U,a)=>(o.gen_message_random++,ee.create({}).update(u).update(U).update(a).digest().subarray(0,n)),Hmsg:(u,U,a,l)=>(o.hmsg++,ee.create({}).update(u.subarray(0,n)).update(U).update(a).xof(l)),thash1:i.bind(null,1),thashN:i,clean:()=>{s.destroy(),c.destroy()}}},st={getContext:ro()},rn=Ae(me["128f"],st),nn=Ae(me["128s"],st),on=Ae(me["192f"],st),sn=Ae(me["192s"],st),cn=Ae(me["256f"],st),an=Ae(me["256s"],st),un=(e,t)=>r=>(n,o)=>{let{N:s}=r,c={prf:0,thash:0,hmsg:0,gen_message_random:0,mgf1:0},i=new Uint8Array(4),u=We(i),U=e.create().update(n).update(new Uint8Array(e.blockLen-s)),a=t.create().update(n).update(new Uint8Array(t.blockLen-s)),l=U.clone(),S=a.clone();function m(P,F,K){c.mgf1++;let A=new Uint8Array(Math.ceil(F/K.outputLen)*K.outputLen);if(F>2**32)throw new Error("mask too long");for(let h=0,H=A;H.length;h++)u.setUint32(0,h,!1),K.create().update(P).update(i).digestInto(H),H=H.subarray(K.outputLen);return Y(A.subarray(F)),A.subarray(0,F)}let B=(P,F,K)=>(A,h,H)=>(c.thash++,F._cloneInto(K).update(H).update(h.subarray(0,A*s)).digest().subarray(0,s));return{PRFaddr:P=>{if(!o)throw new Error("No sk seed");return c.prf++,U._cloneInto(l).update(P).update(o).digest().subarray(0,s)},PRFmsg:(P,F,K)=>(c.gen_message_random++,er.create(t,P).update(F).update(K).digest().subarray(0,s)),Hmsg:(P,F,K,A)=>{c.hmsg++;let h=Ve(P.subarray(0,s),F.subarray(0,s),t.create().update(P.subarray(0,s)).update(F).update(K).digest());return m(h,A,t)},thash1:B(e,U,l).bind(null,1),thashN:B(t,a,S),clean:()=>{U.destroy(),a.destroy(),l.destroy(),S.destroy()}}},fn={isCompressed:!0,getContext:un(Rt,Rt)},Ft={isCompressed:!0,getContext:un(Rt,en)},ln=Ae(me["128f"],fn),dn=Ae(me["128s"],fn),hn=Ae(me["192f"],Ft),yn=Ae(me["192s"],Ft),pn=Ae(me["256f"],Ft),bn=Ae(me["256s"],Ft);return Un(no);})();
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/

    function getKem() {
      const kem = (globalThis.noblePostQuantum && globalThis.noblePostQuantum.ml_kem1024) || globalThis.ml_kem1024;
      if (!kem) throw new Error('noble-post-quantum not loaded or not a standalone build');
      if (!globalThis.crypto || !globalThis.crypto.getRandomValues) throw new Error('Web Crypto API not available');
      return kem;
    }
    function concatBytes() {
      const arrs = Array.from(arguments);
      const total = arrs.reduce((a,b)=>a + b.length, 0);
      const out = new Uint8Array(total);
      let off = 0;
      for (const a of arrs) { out.set(a, off); off += a.length; }
      return out;
    }
    function utf8(s){ return new TextEncoder().encode(s); }
    function toBE16(n){ return new Uint8Array([(n>>>8)&255, n&255]); }
    function fromBE16(hi, lo){ return ((hi&255)<<8) | (lo&255); }
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }
    function base64ToArrayBuffer(base64) {
      const binary = atob(base64.replace(/\s+/g,''));
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }
    function serializeHybridPublic(kemPub, ecPubRaw){
      const a = toBE16(kemPub.length);
      const b = toBE16(ecPubRaw.length);
      return concatBytes(a, kemPub, b, ecPubRaw);
    }
    function serializeHybridPrivate(kemSec, ecPrivPkcs8){
      const a = toBE16(kemSec.length);
      const b = toBE16(ecPrivPkcs8.length);
      return concatBytes(a, kemSec, b, ecPrivPkcs8);
    }
    function parseHybridPublic(u8){
      if (u8.length < 2) throw new Error('Invalid public key');
      const kemLen = fromBE16(u8[0], u8[1]);
      if (u8.length < 2 + kemLen + 2) throw new Error('Invalid public key');
      const kemPub = u8.slice(2, 2 + kemLen);
      const p = 2 + kemLen;
      const ecLen = fromBE16(u8[p], u8[p+1]);
      if (u8.length !== p + 2 + ecLen) throw new Error('Invalid public key');
      const ecPubRaw = u8.slice(p + 2);
      return { kemPub, ecPubRaw };
    }
    function parseHybridPrivate(u8){
      if (u8.length < 2) throw new Error('Invalid private key');
      const kemLen = fromBE16(u8[0], u8[1]);
      if (u8.length < 2 + kemLen + 2) throw new Error('Invalid private key');
      const kemSec = u8.slice(2, 2 + kemLen);
      const p = 2 + kemLen;
      const ecLen = fromBE16(u8[p], u8[p+1]);
      if (u8.length !== p + 2 + ecLen) throw new Error('Invalid private key');
      const ecPrivPkcs8 = u8.slice(p + 2);
      return { kemSec, ecPrivPkcs8 };
    }
    function buildHeader(iv, kemCtLen, salt, epkLen){
      const hdr = new Uint8Array(12 + 2 + 16 + 2);
      hdr.set(iv, 0);
      hdr[12] = (kemCtLen>>>8)&255;
      hdr[13] = kemCtLen&255;
      hdr.set(salt, 14);
      const q = 30;
      hdr[q]   = (epkLen>>>8)&255;
      hdr[q+1] = epkLen&255;
      return hdr;
    }
    function parseHeader(u8){
      if (u8.length < 12+2+16+2) throw new Error('Ciphertext too short');
      const iv = u8.slice(0,12);
      const kemCtLen = (u8[12]<<8) | u8[13];
      const salt = u8.slice(14,30);
      const epkLen = (u8[30]<<8) | u8[31];
      const off = 32;
      return {iv, kemCtLen, salt, epkLen, off};
    }
    async function hkdfAesKey(ikmBytes, salt, infoBytes) {
      const ikm = await crypto.subtle.importKey("raw", ikmBytes, "HKDF", false, ["deriveKey"]);
      const key = await crypto.subtle.deriveKey(
        { name: "HKDF", hash: "SHA-256", salt, info: infoBytes },
        ikm,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
      return key;
    }
    async function generateKeys() {
      const btn = document.getElementById('generateBtn');
      const original = btn.innerText;
      btn.disabled = true;
      btn.innerText = 'Generating...';
      try {
        const kem = getKem();
        const seed = crypto.getRandomValues(new Uint8Array(64));
        const kemKeys = kem.keygen(seed);
        const ecKeys = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveBits']);
        const ecPubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', ecKeys.publicKey));
        const ecPrivPkcs8 = new Uint8Array(await crypto.subtle.exportKey('pkcs8', ecKeys.privateKey));
        const pubPacked = serializeHybridPublic(new Uint8Array(kemKeys.publicKey.buffer), ecPubRaw);
        const secPacked = serializeHybridPrivate(new Uint8Array(kemKeys.secretKey.buffer), ecPrivPkcs8);
        document.getElementById('publicKey').value  = arrayBufferToBase64(pubPacked.buffer);
        document.getElementById('privateKey').value = arrayBufferToBase64(secPacked.buffer);
        btn.innerText = 'Keys Generated!';
      } catch (err) {
        alert('Key generation failed: ' + err.message);
        console.error(err);
        btn.innerText = 'Generation Failed';
      } finally {
        setTimeout(()=>{ btn.innerText = original; btn.disabled = false; }, 1500);
      }
    }
    async function encryptText() {
      try {
        const kem = getKem();
        const plaintext = document.getElementById('plaintext').value;
        const publicKeyBase64 = document.getElementById('publicKey').value;
        if (!plaintext || !publicKeyBase64) { alert('Please provide plaintext and public key.'); return; }
        const pubPacked = new Uint8Array(base64ToArrayBuffer(publicKeyBase64));
        const parsedPub = parseHybridPublic(pubPacked);
        const kemPub = parsedPub.kemPub;
        const ecPubRaw = parsedPub.ecPubRaw;
        const recipientEcPub = await crypto.subtle.importKey('raw', ecPubRaw, {name:'ECDH', namedCurve:'P-256'}, false, []);
        const eph = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveBits']);
        const ephPubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', eph.publicKey));
        const ecdhBits = new Uint8Array(await crypto.subtle.deriveBits({name:'ECDH', public: recipientEcPub}, eph.privateKey, 256));
        const r = kem.encapsulate(kemPub);
        const kemCt = r.cipherText;
        const kemSS = r.sharedSecret;
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const header = buildHeader(iv, kemCt.length, salt, ephPubRaw.length);
        const info = concatBytes(utf8('HYBRID-MLKEM1024+P256+AESGCM v1'), header, new Uint8Array(kemCt), ephPubRaw);
        const ikm = concatBytes(new Uint8Array(kemSS), ecdhBits);
        const aesKey = await hkdfAesKey(ikm, salt, info);
        const enc = new TextEncoder();
        const aad = header;
        const encrypted = await crypto.subtle.encrypt({name: "AES-GCM", iv, additionalData: aad, tagLength: 128}, aesKey, enc.encode(plaintext));
        const out = concatBytes(header, new Uint8Array(kemCt), ephPubRaw, new Uint8Array(encrypted));
        const base64 = arrayBufferToBase64(out.buffer);
        document.getElementById('outputMessage').value = base64;
        document.getElementById('outputLabel').textContent = 'Encrypted Text (Base64)';
        document.getElementById('ciphertext').value = base64;
      } catch (err) {
        document.getElementById('outputMessage').value = 'Encryption failed: ' + err.message;
        document.getElementById('outputLabel').textContent = 'Output';
        console.error(err);
      }
    }
    async function decryptText() {
      try {
        const kem = getKem();
        const ciphertextBase64 = document.getElementById('ciphertext').value;
        const privateKeyBase64 = document.getElementById('privateKey').value;
        if (!ciphertextBase64 || !privateKeyBase64) { alert('Please provide encrypted text and private key.'); return; }
        const blob = new Uint8Array(base64ToArrayBuffer(ciphertextBase64));
        const h = parseHeader(blob);
        const minLen = h.off + h.kemCtLen + h.epkLen + 16;
        if (blob.length < minLen) throw new Error('Ciphertext truncated');
        const kemCt = blob.slice(h.off, h.off + h.kemCtLen);
        const epkRaw = blob.slice(h.off + h.kemCtLen, h.off + h.kemCtLen + h.epkLen);
        const body = blob.slice(h.off + h.kemCtLen + h.epkLen);
        const header = buildHeader(h.iv, h.kemCtLen, h.salt, h.epkLen);
        const privPacked = new Uint8Array(base64ToArrayBuffer(privateKeyBase64));
        const parsedPriv = parseHybridPrivate(privPacked);
        const kemSec = parsedPriv.kemSec;
        const ecPrivPkcs8 = parsedPriv.ecPrivPkcs8;
        const ecPriv = await crypto.subtle.importKey('pkcs8', ecPrivPkcs8, {name:'ECDH', namedCurve:'P-256'}, false, ['deriveBits']);
        const senderEphPub = await crypto.subtle.importKey('raw', epkRaw, {name:'ECDH', namedCurve:'P-256'}, false, []);
        const ecdhBits = new Uint8Array(await crypto.subtle.deriveBits({name:'ECDH', public: senderEphPub}, ecPriv, 256));
        const kemSS = kem.decapsulate(kemCt, kemSec);
        const info = concatBytes(utf8('HYBRID-MLKEM1024+P256+AESGCM v1'), header, kemCt, epkRaw);
        const ikm = concatBytes(new Uint8Array(kemSS), ecdhBits);
        const aesKey = await hkdfAesKey(ikm, h.salt, info);
        const pt = await crypto.subtle.decrypt({name: "AES-GCM", iv: h.iv, additionalData: header, tagLength: 128}, aesKey, body);
        const dec = new TextDecoder();
        document.getElementById('outputMessage').value = dec.decode(pt);
        document.getElementById('outputLabel').textContent = 'Decrypted Message';
      } catch (err) {
        document.getElementById('outputMessage').value = 'Decryption failed: ' + err.message;
        document.getElementById('outputLabel').textContent = 'Output';
        console.error(err);
      }
    }
    async function copyText(id) {
      const text = document.getElementById(id).value;
      try { await navigator.clipboard.writeText(text); alert('Copied to clipboard!'); }
      catch (err) { console.error('Copy failed:', err); }
    }
    function clearField(id) { document.getElementById(id).value = ''; }
    function clearAll() {
      document.getElementById('publicKey').value = '';
      document.getElementById('privateKey').value = '';
      document.getElementById('plaintext').value = '';
      document.getElementById('ciphertext').value = '';
      document.getElementById('outputMessage').value = '';
      document.getElementById('outputLabel').textContent = 'Output';
    }
  </script>
</body>
</html>
