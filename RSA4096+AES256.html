<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Security-Policy"
      content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline'; img-src 'self' data:; base-uri 'none'; form-action 'none'; connect-src 'none'">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RSA-4096 Hybrid (OAEP + AES-256-GCM)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    textarea, button {
      width: 100%;
      margin: 10px 0;
      padding: 10px;
      font-size: 16px;
    }
    textarea {
      height: 120px;
    }
    .output {
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 10px;
        height: 150px;
        overflow-y: auto;
        overflow-x: hidden;
        white-space: pre-wrap;
        word-break: break-all;
        font-family: ui-monospace, monospace;
    }
  </style>
</head>
<body>
  <h1>RSA-4096 Hybrid (OAEP + AES-256-GCM)</h1>

  <button id="generateBtn" onclick="generateKeys()">Generate RSA-4096 Key Pair</button>  
  <h3>Public Key (PEM format)</h3>
  <textarea id="publicKey" placeholder="Public key will appear here..."></textarea>
  <button onclick="copyText('publicKey')">Copy Public Key</button>

  <h3>Private Key (PEM format)</h3>
  <textarea id="privateKey" placeholder="Private key will appear here..."></textarea>
  <button onclick="copyText('privateKey')">Copy Private Key</button>

  <h3>Text to Encrypt</h3>
  <textarea id="plaintext" placeholder="Enter text to encrypt..."></textarea>
  <button onclick="encryptText()">Encrypt</button>

  <h3>Encrypted Text (Base64)</h3>
  <div class="output" id="encryptedMessage"></div>
  <button onclick="copyDiv('encryptedMessage')">Copy Encrypted Text</button>

  <h3>Text to Decrypt</h3>
  <textarea id="ciphertext" placeholder="Paste encrypted text here..."></textarea>
  <button onclick="decryptText()">Decrypt</button>

  <h3>Decrypted Message</h3>
  <div class="output" id="decryptedMessage"></div>
  <button onclick="copyDiv('decryptedMessage')">Copy Decrypted Text</button>

  <script>
    const OAEP_LABEL = new TextEncoder().encode("hyb:v1");

    let cryptoKeyPair;

    async function generateKeys() {
      const generateBtn = document.getElementById('generateBtn');
      const originalText = generateBtn.innerText;
      generateBtn.disabled = true;
      generateBtn.innerText = 'Generating...';

      cryptoKeyPair = await window.crypto.subtle.generateKey(
        {
          name: "RSA-OAEP",
          modulusLength: 4096,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: "SHA-256"
        },
        true,
        ["wrapKey", "unwrapKey"]
      );

      const publicKey = await window.crypto.subtle.exportKey("spki", cryptoKeyPair.publicKey);
      const privateKey = await window.crypto.subtle.exportKey("pkcs8", cryptoKeyPair.privateKey);

      document.getElementById('publicKey').value = pemEncode(publicKey, "PUBLIC KEY");
      document.getElementById('privateKey').value = pemEncode(privateKey, "PRIVATE KEY");

      generateBtn.innerText = ' Keys Generated!';
      setTimeout(() => {
        generateBtn.innerText = originalText;
        generateBtn.disabled = false;
      }, 1500);
    }

    function concatBytes(...arrs){
      const total = arrs.reduce((a,b)=>a + b.length, 0);
      const out = new Uint8Array(total);
      let off = 0;
      for(const a of arrs){ out.set(a, off); off += a.length; }
      return out;
    }
    function buildHeader(iv, wrappedLen){
      const hdr = new Uint8Array(12 + 2);
      hdr.set(iv, 0);
      hdr[12] = (wrappedLen >>> 8) & 0xff;
      hdr[13] = (wrappedLen       ) & 0xff;
      return hdr;
    }

function parseHeader(u8){
     if(u8.length < 14) throw new Error('Ciphertext too short');
     const iv = u8.slice(0, 12);
     const wrappedLen = (u8[12] << 8) | u8[13];
     const off = 14;
     return {iv, wrappedLen, off};
    }

    async function encryptText() {
      try {
        const plaintext = document.getElementById('plaintext').value;
        const publicKeyPem = document.getElementById('publicKey').value;
        if (!plaintext || !publicKeyPem) {
          alert('Please provide plaintext and public key.');
          return;
        }
        const enc = new TextEncoder();
        const publicKey = await importKey(publicKeyPem, "public");

        const aesKey = await crypto.subtle.generateKey({name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);

        const wrapped = await crypto.subtle.wrapKey(
          "raw", aesKey, publicKey,
          {name:"RSA-OAEP", label: OAEP_LABEL}
        );
        const wrappedU8 = new Uint8Array(wrapped);

        const iv = crypto.getRandomValues(new Uint8Array(12));
        const header = buildHeader(iv, wrappedU8.length);
        const aad = header;

        const ct = await crypto.subtle.encrypt(
          {name:"AES-GCM", iv, additionalData: aad, tagLength:128},
          aesKey,
          enc.encode(plaintext)
        );

        const out = concatBytes(header, wrappedU8, new Uint8Array(ct));
        const base64 = arrayBufferToBase64(out.buffer);

        document.getElementById('encryptedMessage').textContent = base64;
        document.getElementById('ciphertext').value = base64;
      } catch (err) {
        document.getElementById('encryptedMessage').textContent = 'Encryption failed: ' + err.message;
      }
    }

    async function decryptText() {
      try {
        const ciphertextBase64 = document.getElementById('ciphertext').value;
        const privateKeyPem = document.getElementById('privateKey').value;
        if (!ciphertextBase64 || !privateKeyPem) {
          alert('Please provide encrypted text and private key.');
          return;
        }
        const dec = new TextDecoder();
        const privateKey = await importKey(privateKeyPem, "private");

        const blob = new Uint8Array(base64ToArrayBuffer(ciphertextBase64));
        const {iv, wrappedLen, off} = parseHeader(blob);
        const wrapped = blob.slice(off, off + wrappedLen);
        const body    = blob.slice(off + wrappedLen);

        const header = buildHeader(iv, wrappedLen);
        const aad = header;

        const aesKey = await crypto.subtle.unwrapKey(
          "raw", wrapped.buffer.slice(wrapped.byteOffset, wrapped.byteOffset + wrapped.byteLength), privateKey,
          {name:"RSA-OAEP", label: OAEP_LABEL},
          {name:"AES-GCM", length:256},
          false, ["decrypt"]
        );

        const pt = await crypto.subtle.decrypt(
          {name:"AES-GCM", iv, additionalData: aad, tagLength:128},
          aesKey,
          body
        );

        document.getElementById('decryptedMessage').textContent = dec.decode(pt);
      } catch (err) {
        document.getElementById('decryptedMessage').textContent = 'Decryption failed: ' + err.message;
      }
    }

    function pemEncode(buffer, label) {
      const base64 = arrayBufferToBase64(buffer);
      const lines = base64.match(/.{1,64}/g).join('\n');
      return `-----BEGIN ${label}-----\n${lines}\n-----END ${label}-----`;
    }

    async function importKey(pem, type) {
      const b64 = pem.replace(/-----[^-]+-----/g, '').replace(/\s+/g, '');
      const raw = base64ToArrayBuffer(b64);
      if (type === "public") {
        return await window.crypto.subtle.importKey(
          "spki",
          raw,
          { name: "RSA-OAEP", hash: "SHA-256" },
          true,
          ["wrapKey"]
        );
      } else {
        return await window.crypto.subtle.importKey(
          "pkcs8",
          raw,
          { name: "RSA-OAEP", hash: "SHA-256" },
          true,
          ["unwrapKey"]
        );
      }
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
      const binary = atob(base64.replace(/\s+/g,''));
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    async function copyText(id) {
      const text = document.getElementById(id).value;
      try {
        await navigator.clipboard.writeText(text);
        alert('Copied to clipboard!');
      } catch (err) {
        console.error('Copy failed:', err);
      }
    }

    async function copyDiv(id) {
      const text = document.getElementById(id).textContent;
      try {
        await navigator.clipboard.writeText(text);
        alert('Copied to clipboard!');
      } catch (err) {
        console.error('Copy failed:', err);
      }
    }
  </script>
</body>
</html>
