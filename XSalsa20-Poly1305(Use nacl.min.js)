<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>XSalsa20-Poly1305 Text Encryptor</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'self' 'unsafe-inline'; img-src 'self' data:; base-uri 'none'; form-action 'none'; connect-src 'none';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:20px;line-height:1.45}
    h1{font-size:20px;margin:0 0 10px}
    .row{margin:10px 0}
    .label{font-weight:600;margin:6px 0;display:block}
    textarea,input,button{width:100%;font-size:15px;padding:10px;box-sizing:border-box}
    textarea{height:150px;resize:vertical}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .hint{color:#666;font-size:12px}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .ok{color:#0a7d00}.err{color:#b00020}
  </style>
</head>
<body>
  <h1>XSalsa20-Poly1305 Text Encryptor</h1>

  <div class="row">
    <span class="label">Input (plaintext to encrypt or ciphertext to decrypt, Base64URL)</span>
    <textarea id="io" class="mono" placeholder="Enter plaintext to encrypt or paste ciphertext to decrypt" spellcheck="false"></textarea>
  </div>

  <div class="cols">
    <div class="row">
      <span class="label">Password (high-entropy, â‰¥ 32 chars recommended)</span>
      <input id="pwd" type="password" class="mono" placeholder="Use in an offline clean environment" autocomplete="new-password" autocapitalize="off" spellcheck="false">
    </div>
    <div class="row">
      <span class="label">PBKDF2 Iterations (default 200000)</span>
      <input id="iters" type="number" class="mono" min="10000" max="5000000" step="1000" value="200000">
      <div class="hint">The iteration count is stored in the ciphertext header; decryption enforces a policy range.</div>
    </div>
  </div>

  <div class="row">
    <span class="label">AAD Context (optional, must match on both sides)</span>
    <input id="aad" type="text" class="mono" value="">
    <div class="hint">Empty by default. Participates in authentication only (not encrypted).</div>
  </div>

  <div class="cols">
    <button id="encBtn">Encrypt (XSalsa20-Poly1305)</button>
    <button id="decBtn">Decrypt (XSalsa20-Poly1305)</button>
  </div>

  <div class="cols" style="margin-top:6px">
    <button id="copyBtn">Copy Output</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div id="status" class="hint" style="margin-top:8px"></div>

  <script>
  const enc = new TextEncoder(), dec = new TextDecoder();

  function b64uEncode(u8){
    let s = '', chunk = 0x8000;
    for(let i=0;i<u8.length;i+=chunk){
      s += String.fromCharCode.apply(null, u8.subarray(i, i+chunk));
    }
    return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function b64uDecode(str){
    str = (str||'').replace(/[\r\n\s]/g,'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = str.length % 4 ? '='.repeat(4 - (str.length % 4)) : '';
    const bin = atob(str + pad);
    const u8 = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
    return u8;
  }
  function concatBytes(...arrs){
    const total = arrs.reduce((a,b)=>a + b.length, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for(const a of arrs){ out.set(a, off); off += a.length; }
    return out;
  }
  function eqBytes(a,b){
    if(a.length !== b.length) return false;
    let v = 0;
    for(let i=0;i<a.length;i++) v |= a[i]^b[i];
    return v===0;
  }

  const VER = 0x01;
  const KDF_PBKDF2 = 0x01;
  const HEADER_LEN = 16 + 24 + 1 + 1 + 4;
  const HMAC_LEN = 32;
  const MIN_ITERS = 10_000;
  const MAX_ITERS = 5_000_000;

  function buildHeader(iter, salt, nonce){
    const hdr = new Uint8Array(HEADER_LEN);
    hdr.set(salt, 0);
    hdr.set(nonce, 16);
    hdr[40] = VER;
    hdr[41] = KDF_PBKDF2;
    new DataView(hdr.buffer).setUint32(42, iter >>> 0, true);
    return hdr;
  }
  function parseAll(u8){
    if(u8.length < HEADER_LEN + HMAC_LEN + 16) throw new Error('Ciphertext too short');
    const salt = u8.slice(0,16);
    const nonce = u8.slice(16,40);
    const ver = u8[40];
    const kdf = u8[41];
    const iter = new DataView(u8.buffer, u8.byteOffset+42, 4).getUint32(0, true);
    const macOff = u8.length - HMAC_LEN;
    const body = u8.slice(HEADER_LEN, macOff);
    const hmac = u8.slice(macOff);
    if(ver !== VER) throw new Error('Version mismatch');
    if(kdf !== KDF_PBKDF2) throw new Error('Unsupported KDF');
    return {iter, salt, nonce, body, hmac, header: u8.slice(0, HEADER_LEN)};
  }

  async function pbkdf2_512(passwordUtf8, salt, iterations){
    const keyMat = await crypto.subtle.importKey('raw', passwordUtf8, 'PBKDF2', false, ['deriveBits']);
    const bits = await crypto.subtle.deriveBits({name:'PBKDF2', salt, iterations, hash:'SHA-256'}, keyMat, 512);
    return new Uint8Array(bits); // 64 bytes
  }
  async function hmac_sha256(keyRaw32, data){
    const key = await crypto.subtle.importKey('raw', keyRaw32, {name:'HMAC', hash:'SHA-256'}, false, ['sign']);
    const sig = await crypto.subtle.sign('HMAC', key, data);
    return new Uint8Array(sig); // 32 bytes
  }

  const $io = document.getElementById('io');
  const $pwd = document.getElementById('pwd');
  const $iters = document.getElementById('iters');
  const $aad = document.getElementById('aad');
  const $encBtn = document.getElementById('encBtn');
  const $decBtn = document.getElementById('decBtn');
  const $copy = document.getElementById('copyBtn');
  const $clear = document.getElementById('clearBtn');
  const $status = document.getElementById('status');

  function setStatus(msg, ok=false){
    $status.textContent = msg || '';
    $status.className = msg ? (ok ? 'ok' : 'err') : 'hint';
  }
  function failAuth(){
    setStatus('Decryption failed: password or AAD mismatch (authentication failed)', false);
  }

  (function envCheck(){
    if(!crypto || !crypto.getRandomValues) alert('Missing secure RNG (crypto.getRandomValues).');
    if(!crypto.subtle) alert('Missing WebCrypto SubtleCrypto.');
  })();

  $encBtn.onclick = async () => {
    try{
      setStatus('');
      const text = ($io.value ?? '').toString();
      const pwd  = ($pwd.value ?? '').toString();
      const aadStr = ($aad.value ?? '').toString();
      let iters = parseInt($iters.value||'0',10) || 200000;
      iters = Math.max(MIN_ITERS, Math.min(MAX_ITERS, iters));
      if(!text) throw new Error('Plaintext is empty');
      if(!pwd)  throw new Error('Password is empty');

      if(!(window.nacl && nacl.secretbox)) throw new Error('TweetNaCl not loaded');

      const salt = crypto.getRandomValues(new Uint8Array(16));
      const nonce = crypto.getRandomValues(new Uint8Array(24));
      const k64 = await pbkdf2_512(enc.encode(pwd), salt, iters);
      const encKey = k64.slice(0,32);
      const macKey = k64.slice(32,64);
      const msg = enc.encode(text);
      const box = nacl.secretbox(msg, nonce, encKey);
      const header = buildHeader(iters, salt, nonce);
      const aad = aadStr ? enc.encode(aadStr) : new Uint8Array(0);
      const mac = await hmac_sha256(macKey, concatBytes(header, box, aad));
      const out = concatBytes(header, box, mac);
      const b64u = b64uEncode(out);

      $io.value = b64u;
      setStatus('Encryption complete', true);

      salt.fill(0); nonce.fill(0); encKey.fill(0); macKey.fill(0); k64.fill(0);
    }catch(e){
      setStatus('Encryption failed: ' + (e.message || e), false);
    }
  };

  $decBtn.onclick = async () => {
    try{
      setStatus('');
      const b64u = ($io.value ?? '').toString();
      const pwd  = ($pwd.value ?? '').toString();
      const aadStr = ($aad.value ?? '').toString();
      if(!b64u) throw new Error('Ciphertext is empty');
      if(!pwd)  throw new Error('Password is empty');
      if(!(window.nacl && nacl.secretbox)) throw new Error('TweetNaCl not loaded');

      const blob = b64uDecode(b64u);
      const {iter, salt, nonce, body, hmac, header} = parseAll(blob);
      if(iter < MIN_ITERS || iter > MAX_ITERS) throw new Error('Iterations out of policy');

      const k64 = await pbkdf2_512(enc.encode(pwd), salt, iter);
      const encKey = k64.slice(0,32);
      const macKey = k64.slice(32,64);
      const aad = aadStr ? enc.encode(aadStr) : new Uint8Array(0);

      const macCalc = await hmac_sha256(macKey, concatBytes(header, body, aad));
      if(!eqBytes(macCalc, hmac)) return failAuth();

      const msg = nacl.secretbox.open(body, nonce, encKey);
      if(!msg) return failAuth();

      const plain = dec.decode(msg);
      $io.value = plain;
      setStatus('Decryption successful (iterations=' + iter + ')', true);

      salt.fill(0); nonce.fill(0); encKey.fill(0); macKey.fill(0); k64.fill(0);
    }catch(e){
      setStatus(e.message || String(e), false);
    }
  };

  $copy.onclick = async () => {
    try{
      if(!$io.value) return setStatus('Nothing to copy', false);
      await navigator.clipboard.writeText($io.value);
      setStatus('Copied to clipboard', true);
      setTimeout(()=>setStatus(''), 1200);
    }catch(e){
      setStatus('Copy failed: ' + (e.message || e), false);
    }
  };
  $clear.onclick = () => { $io.value=''; setStatus(''); };
  </script>

  <script src="nacl.min.js"></script>
</body>
</html>
